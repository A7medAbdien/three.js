
## main model file

```js
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef } from "react";
import { useGLTF } from "@react-three/drei";

export function Model(props) {
  const { nodes, materials } = useGLTF("/boxWithSb7a2.glb");
  return (
    <group {...props} dispose={null}>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube.geometry}
        material={nodes.Cube.material}
        position={[0, 0.07, -0.22]}
        rotation={[Math.PI / 2, Math.PI / 6, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.baseOutFront.geometry}
        material={nodes.baseOutFront.material}
        position={[-0.45, 1.23, 0.37]}
        rotation={[Math.PI / 2, 0, -Math.PI]}
        scale={[1, 1, 1.5]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere001.geometry}
        material={nodes.Sphere001.material}
        position={[-0.3, 0.23, 0.43]}
        rotation={[Math.PI / 2, -1.18, Math.PI / 2]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere002.geometry}
        material={nodes.Sphere002.material}
        position={[0.01, 0.39, 0.43]}
        rotation={[Math.PI / 2, 1.16, Math.PI / 2]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere003.geometry}
        material={nodes.Sphere003.material}
        position={[0.16, 0.65, 0.43]}
        rotation={[Math.PI / 2, 1.07, Math.PI / 2]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere004.geometry}
        material={nodes.Sphere004.material}
        position={[-0.46, 0.48, 0.43]}
        rotation={[Math.PI / 2, -1.21, Math.PI / 2]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere005.geometry}
        material={nodes.Sphere005.material}
        position={[-0.64, 0.73, 0.43]}
        rotation={[Math.PI / 2, -1.16, Math.PI / 2]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere006.geometry}
        material={nodes.Sphere006.material}
        position={[-0.79, 0.98, 0.43]}
        rotation={[Math.PI / 2, -1.2, Math.PI / 2]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere007.geometry}
        material={nodes.Sphere007.material}
        position={[-0.93, 1.23, 0.43]}
        rotation={[Math.PI / 2, -1.31, Math.PI / 2]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere008.geometry}
        material={nodes.Sphere008.material}
        position={[-1.06, 1.5, 0.43]}
        rotation={[1.57, -1.42, 1.57]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere009.geometry}
        material={nodes.Sphere009.material}
        position={[-0.02, 0.1, 0.43]}
        rotation={[1.57, 1.57, 1.57]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere010.geometry}
        material={nodes.Sphere010.material}
        position={[-1.15, 1.88, 0.17]}
        rotation={[-1.41, -1.57, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere011.geometry}
        material={nodes.Sphere011.material}
        position={[0.28, 0.88, 0.2]}
        rotation={[-Math.PI, 1.57, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere012.geometry}
        material={nodes.Sphere012.material}
        position={[0.28, 0.88, -0.13]}
        rotation={[-Math.PI, 1.57, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere013.geometry}
        material={nodes.Sphere013.material}
        position={[0.23, 0.61, -0.38]}
        rotation={[-Math.PI, 1.57, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere015.geometry}
        material={nodes.Sphere015.material}
        position={[-1.14, 1.89, -0.13]}
        rotation={[-1.75, -1.57, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere016.geometry}
        material={nodes.Sphere016.material}
        position={[-1.08, 1.63, -0.39]}
        rotation={[-Math.PI, 1.57, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere017.geometry}
        material={nodes.Sphere017.material}
        position={[-1.11, 1.34, -0.39]}
        rotation={[-Math.PI, 1.57, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere032.geometry}
        material={nodes.Sphere032.material}
        position={[0.15, -0.7, -0.39]}
        rotation={[-Math.PI, 1.57, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere033.geometry}
        material={nodes.Sphere033.material}
        position={[0.23, -0.42, -0.39]}
        rotation={[-Math.PI, 1.57, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere034.geometry}
        material={nodes.Sphere034.material}
        position={[0.24, -0.12, -0.39]}
        rotation={[-Math.PI, 1.57, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere035.geometry}
        material={nodes.Sphere035.material}
        position={[0.24, 0.19, -0.39]}
        rotation={[-Math.PI, 1.57, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere018.geometry}
        material={nodes.Sphere018.material}
        position={[-1.11, 1.06, -0.39]}
        rotation={[0, -1.57, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere019.geometry}
        material={nodes.Sphere019.material}
        position={[-1.13, 0.76, -0.39]}
        rotation={[0, -1.57, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere020.geometry}
        material={nodes.Sphere020.material}
        position={[-1.14, 0.46, -0.39]}
        rotation={[0, -1.57, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere021.geometry}
        material={nodes.Sphere021.material}
        position={[-1.13, 0.16, -0.39]}
        rotation={[0, -1.57, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere022.geometry}
        material={nodes.Sphere022.material}
        position={[-1.13, -0.13, -0.39]}
        rotation={[0, -1.57, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere023.geometry}
        material={nodes.Sphere023.material}
        position={[-1.12, -0.43, -0.39]}
        rotation={[0, -1.57, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere024.geometry}
        material={nodes.Sphere024.material}
        position={[-1.1, -0.73, -0.39]}
        rotation={[Math.PI / 2, -1.51, Math.PI / 2]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere025.geometry}
        material={nodes.Sphere025.material}
        position={[-1.07, -1.03, -0.39]}
        rotation={[Math.PI / 2, -1.41, Math.PI / 2]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere026.geometry}
        material={nodes.Sphere026.material}
        position={[-0.97, -1.3, -0.39]}
        rotation={[-Math.PI / 2, 1.32, -Math.PI / 2]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere027.geometry}
        material={nodes.Sphere027.material}
        position={[-0.79, -1.53, -0.39]}
        rotation={[Math.PI / 2, -0.93, Math.PI / 2]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere028.geometry}
        material={nodes.Sphere028.material}
        position={[-0.51, -1.6, -0.39]}
        rotation={[Math.PI / 2, 0.03, Math.PI / 2]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere029.geometry}
        material={nodes.Sphere029.material}
        position={[-0.24, -1.5, -0.39]}
        rotation={[Math.PI / 2, 0.89, Math.PI / 2]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere030.geometry}
        material={nodes.Sphere030.material}
        position={[-0.07, -1.25, -0.39]}
        rotation={[Math.PI / 2, 1.04, Math.PI / 2]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Sphere031.geometry}
        material={nodes.Sphere031.material}
        position={[0.05, -0.98, -0.39]}
        rotation={[Math.PI / 2, 1.21, Math.PI / 2]}
      />
    </group>
  );
}

useGLTF.preload("/boxWithSb7a2.glb");

```

## RigidBody current options

addForce
addForceAtPoint
addTorque
angularDamping
angvel
applyImpulse
applyImpulseAtPoint
applyTorqueImpulse
handle
linearDamping
linvel
lockRotations
lockTranslations
mass
raw
resetForces
resetTorques
rotation
setAngularDamping
setAngvel
setEnabledRotations
setEnabledTranslations
setLinearDamping
setLinvel
setNextKinematicRotation
setNextKinematicTranslation
setRotation
setTranslation
translation

# Help

## How to make a Spherical Joint anchor follow an object
I mean by Spherical Joint anchor, is the same as the one is used in [the rapier documentation example][1] . I mean by an object, a .glTF model that I loaded. 


I am trying to make the anchor, Spherical Joint anchor, to follow the edge of the model, when it rotate or moves.

I was able to make the anchor follows the model position using this method, and I call it on each frame

```js
const move = (leftAnchor, rightAnchor) => {

    /**
     *  model: a reference for the group that contain the .glTF model
     *  leftAnchorPos: the initial position of the leftAnchor
     *  rightAnchorPos: the initial position of the rightAnchor
     */
    const modelPos = model.current.position
    const leftPos = new Vector3(
        leftAnchorPos.x + modelPos.x,
        leftAnchorPos.y + modelPos.y,
        leftAnchorPos.z + modelPos.z)
    const rightPos = new Vector3(
        rightAnchorPos.x + modelPos.x,
        rightAnchorPos.y + modelPos.y,
        rightAnchorPos.z + modelPos.z)

    leftAnchor.setNextKinematicTranslation(leftPos)
    rightAnchor.setNextKinematicTranslation(rightPos)

}
```

I am struggling with making the anchor moves in the right position to follow the model rotation. I am wondering if there is an easier way to do that.


  [1]: https://codesandbox.io/s/react-three-rapier-joints-mhhbd4

## How to listen to the scroll effect in R3F

I am trying to apply a scroll effect similar to this


## Move

```js
    const leftAnchorPos = { x: -1.11, y: 1.06, z: -0.39 } // from model file
    const rightAnchorPos = { x: 0.05, y: - 0.98, z: -0.39 } // from model file
    const leftInitialAngel = Math.atan(leftAnchorPos.y / leftAnchorPos.x)
    const leftRadius = Math.sqrt(Math.pow(leftAnchorPos.x, 2) + Math.pow(leftAnchorPos.y, 2))
    const rightInitialAngel = Math.atan(rightAnchorPos.y / rightAnchorPos.x)
    const rightRadius = Math.sqrt(Math.pow(rightAnchorPos.x, 2) + Math.pow(rightAnchorPos.y, 2))
    const move = (leftAnchor, rightAnchor) => {

        const modelPos = model.current.position
        const modelRot = model.current.rotation
        const leftPos = new Vector3(
            (leftRadius + modelPos.x) * - Math.cos(modelRot.z + leftInitialAngel),
            (leftRadius + modelPos.y) * - Math.sin(modelRot.z + leftInitialAngel),
            leftAnchorPos.z + modelPos.z)
        const rightPos = new Vector3(
            (rightRadius + modelPos.x) * Math.cos(modelRot.z + rightInitialAngel),
            (rightRadius + modelPos.y) * Math.sin(modelRot.z + rightInitialAngel),
            rightAnchorPos.z + modelPos.z)

        leftAnchor.setNextKinematicTranslation(leftPos)
        rightAnchor.setNextKinematicTranslation(rightPos)

    }
    useFrame((state, delta) => {
        const elapsedTime = state.clock.elapsedTime

        const leftAnchor = refs.current[0].current
        const rightAnchor = refs.current[nodes.length - 1].current
        move(leftAnchor, rightAnchor)

        const rotation = new Quaternion(0, 0, Math.sin(elapsedTime * 2) * 5)
        // leftAnchor?.setRotation(rotation)
        // rightAnchor?.setRotation(rotation)
    })
```